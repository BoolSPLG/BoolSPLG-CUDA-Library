//Heder file "host_boolean_functions.h" - Host CPU Boolean functions 
//System includes
#include <stdio.h>
#include <iostream>
#include <algorithm>

using namespace std;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function find max absolute value in array
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int reduceCPU_max(int* vals, int nvals)
{
	//int cmax = vals[0];

	int cmax = vals[0];

	for (int i = 1; i < nvals; i++)
	{
		cmax = max(abs(vals[i]), cmax);
	}
	return cmax;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function find max absolute value in array AC(f)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int reduceCPU_AC(int nvals, int* rf)
{
	rf[0] = 0;
	int cmax = rf[1];

	for (int i = 2; i < nvals; i++)
	{
		cmax = max(abs(rf[i]), cmax);
	}
	return cmax;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Fast Walsh Transform function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FastWalshTrans(int size, int* BoolSbox, int* walshvec)
{
	int temp = 0, j = 1;
	for (int i = 0; i < size; i++)
	{
		walshvec[i] = 0;
		walshvec[i] = BoolSbox[i];
	}

	while (j < size)
	{
		for (int i = 0; i < size; i++) {
			if ((i & j) == 0)
			{
				temp = walshvec[i];

				walshvec[i] = (walshvec[i] + walshvec[i + j]);
				walshvec[i + j] = (-walshvec[i + j] + temp);
			}
		}
		j = j * 2;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Fast Walsh Transform function “Absolute Bias” 
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FastWalshTrans_AB(int n, int* BoolSbox, int* walshvec)
{
	int temp = 0, j = 1;
	for (int i = 0; i < n; i++)
	{
		walshvec[i] = 0;
		walshvec[i] = BoolSbox[i];
	}

	while (j < n)
	{
		for (int i = 0; i < n; i++) {
			if ((i & j) == 0)
			{
				temp = walshvec[i];

				walshvec[i] = (walshvec[i] + walshvec[i + j])/2;
				walshvec[i + j] = (-walshvec[i + j] + temp)/2;
			}
		}
		j = j * 2;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Invers Fast Walsh Transform function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FastWalshTransInv(int size, int* walshvec)
{
	int temp = 0, j = 1;
	//	for(int i=0; i<n; i++)
	//{
	//	walshvec[i]=0;
	//	walshvec[i]=BoolSbox[i];
	//}

	while (j < size)
	{
		for (int i = 0; i < size; i++)
		{
			if ((i & j) == 0)
			{
				temp = walshvec[i];

				walshvec[i] = (walshvec[i] + walshvec[i + j]) / 2;
				walshvec[i + j] = (-walshvec[i + j] + temp) / 2;
			}
		}
		j = j * 2;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Fast Mobius Transform function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void FastMobiushTrans(int size, int* TT, int* ANF)
{
	int j = 1;
	for (int i = 0; i < size; i++)
	{
		ANF[i] = 0;
		ANF[i] = TT[i];
	}

	while (j < size)
	{
		for (int i = 0; i < size; i++)
		{
			if ((i & j) == j)
			{
				ANF[i] = ANF[i] ^ ANF[i - j];
				//SALg[jj][i]=SALg[jj][i]^SALg[jj][i-j];
			}
		}
		j = j * 2;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Power function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ipow(int base, int exp)
{
	int result = 1;
	while (exp)
	{
		if (exp & 1)
			result *= base;
		exp >>= 1;
		base *= base;
	}

	return result;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Power 2 array function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void fun_pow2(int size, int* vec)
{
	for (int j = 0; j < size; j++)
	{
		vec[j] = ipow(vec[j], 2);

	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU random array fill function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Fill_dp_vector(int n, int* vector_TT, int* vector_PTT)
{
	for (int j = 0; j < n; j++)
	{
		vector_TT[j] = rand() % 2;

		if (vector_TT[j] == 0)
			vector_PTT[j] = 1;
		else
			vector_PTT[j] = -1;
		//Vect[j]=1;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function for check two input arrays and print result
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void check_rez(int size, int* vector1, int* vector2)
{
	bool check = true;
	for (int i = 0; i < size; i++)
	{
		if (vector1[i] != vector2[i])
		{
			check = false;
			break;
		}
	}

	if (check)
		//cout << "\nCheck: True\n";
		printf("\nCheck: True\n");

	else
		printf("\nCheck: False\n");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function for check two input arrays and print result
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void check_rez_int(int size, unsigned long long int* vector1, unsigned long long int* vector2)
{
	bool check = true;
	for (int i = 0; i < size; i++)
	{
		if (vector1[i] != vector2[i])
		{
			check = false;
			break;
		}
	}

	if (check)
		printf("\nCheck: True\n");

	else
		printf("\nCheck: False\n");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function for check two input arrays and print result v0.3
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
void check_rez03(int size, T* vector1, int* vector2)
{
	bool check = true;
	for (int i = 0; i < size; i++)
	{
		if (vector1[i] != vector2[i])
		{
			check = false;
			break;
		}
	}

	if (check)
		printf("\nCheck: True\n");

	else
		printf("\nCheck: False\n");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function for check two input arrays and return result
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//int check_rez_return(int* vector1, int* vector2, int size)
//{
//	bool check = true;
//	for (int i = 0; i < size; i++)
//	{
//		if (vector1[i] != vector2[i])
//		{
//			check = false;
//			break;
//		}
//	}
//
//	if (check)
//		return 1;
//
//	else
//		return 0;
//}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function print array
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Print_Result(int size, int* result)
{
	for (int j = 0; j < size; j++)
	{
		printf("%d, ", result[j]);
	}
	printf("\n\n");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function print array
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//template <class T>
//void Print_Result_v03(int n, T* Result, int size)
//{
//	for (int j = 0; j < size; j++)
//	{
//		printf("%d, ", Result[j]);
//	}
//	printf("\n\n");
//}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function find max algebraic degree
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int FindMaxDeg(int size, int* ANF_CPU)
{
	unsigned int ones = 0, max = 0;// , min = 100;
	for (int i = 0; i < size; i++)
	{
		// code specific to Visual Studio compiler
#if defined (_MSC_VER)
		ones = _mm_popcnt_u32(i) * ANF_CPU[i];
#endif

		// code specific to gcc compiler
#if defined (__GNUC__)
		ones = __builtin_popcount(i) * ANF_CPU[i];
#endif

		if (max < ones)
			max = ones;
		//if ((min>ones)&(ones != 0))
		//	min = ones;

		//cout << ones << " ";
	}
	return max;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Basic Fast Mobiush Transform
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//void FastMobiushTransBitwise(int NumInt, unsigned long long int* TT)
//{
//	int j = 1;
//
//	while (j < NumInt)
//	{
//		for (int i = 0; i <= NumInt; i++)
//		{
//			if ((i & j) == j)
//			{
//				TT[i] = TT[i] ^ TT[i - j];
//				//SALg[jj][i]=SALg[jj][i]^SALg[jj][i-j];
//			}
//		}
//		j = j * 2;
//	}
//}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Main CPU bitwise Fast Mobiush Transform function
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPU_FMT_bitwise(unsigned long long int* NumIntVec, unsigned long long int* NumIntVecANF, int NumInt)
{
	for (int j = 0; j < NumInt; j++)
	{
		unsigned long long  int brez = NumIntVec[j];// , counter1 = 0;

		brez ^= (brez & 12297829382473034410) >> 1;
		brez ^= (brez & 14757395258967641292) >> 2;
		brez ^= (brez & 17361641481138401520) >> 4;
		brez ^= (brez & 18374966859414961920) >> 8;
		brez ^= (brez & 18446462603027742720) >> 16;
		brez ^= (brez & 18446744069414584320) >> 32;

		NumIntVecANF[j] = brez;
	}

	if (NumInt > 1)
	{
		//FastMobiushTransBitwise(NumInt, NumIntVecANF);
		int j = 1;
		while (j < NumInt)
		{
			for (int i = 0; i <= NumInt; i++)
			{
				if ((i & j) == j)
				{
					NumIntVecANF[i] = NumIntVecANF[i] ^ NumIntVecANF[i - j];
				}
			}
			j = j * 2;
		}
	}	
}

////============= CPU function for set TT in 64 bit int variables ==========================
//void BinVecToDec(int size, int *Bin_Vec, unsigned long long int *NumIntVec, int NumInt)
//{
//	for (int i = 0; i<NumInt; i++)
//	{
//		unsigned long long int decimal = 0, sum = 0, bin, counterBin = 0;
//		int set = i*size;
//		//cout << "Set:" << set ;
//		for (int j = ((size - 1) + set); j >= (0 + set); j--)
//		{
//			bin = Bin_Vec[j];
//			decimal = bin << counterBin;
//			counterBin++;
//			sum = sum + decimal;
//		}
//		NumIntVec[i] = sum;
//		//cout << "Number:"<< sum << "\n";
//	}
//}
////=================================================================================

////============= CPU function for set ANF from NumIntVector ==========================
//void DecVecToBin(int NumOfBits, int *Bin_Vec, unsigned long long int *NumIntVec, int NumInt)
//{
//	unsigned long long int number = 0;
//	int c, k, ii = 0;
//
//	for (int i = 0; i<NumInt; i++)
//	{
//		number = NumIntVec[i];
//
//		for (c = NumOfBits - 1; c >= 0; c--)
//		{
//			k = number >> c;
//
//			if (k & 1)
//			{
//				Bin_Vec[ii] = 1;
//				//cout << Bin_Vec[ii] << " ";
//				ii++;
//			}
//			else
//			{
//				Bin_Vec[ii] = 0;
//				//cout << Bin_Vec[ii] << " ";
//				ii++;
//			}
//		}
//		//cout << "Number:"<< sum << "\n";
//	}
//}
////=================================================================================

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU function for set ANF from NumIntVector
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int DecVecToBin_maxDeg(int NumOfBits, unsigned long long int* NumIntVec, int NumInt)
{
	unsigned int ones = 0, max = 0, maxPrime = 0;// , min = 100;

	unsigned long long int number = 0, k = 0;
	unsigned int ii = 0;
	int c;

	bool bit;

	for (int i = 0; i < NumInt; i++)
	{
		number = NumIntVec[i];
		max = 0, k = 0;

		for (c = NumOfBits - 1; c >= 0; c--)
		{
			k = number >> c;

			if (k & 1)
			{
				bit = 1;
				ii++;
			}
			else
			{
				bit = 0;
				ii++;
			}

			// code specific to Visual Studio compiler
#if defined (_MSC_VER)
			ones = _mm_popcnt_u32(ii - 1) * bit;
#endif

			// code specific to gcc compiler
#if defined (__GNUC__)
			ones = __builtin_popcount(ii - 1) * bit;
#endif

			if (max < ones)
				max = ones;
		}
		if (maxPrime < max)
			maxPrime = max;
	}
	return maxPrime;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//CPU Histogram Spectra
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
void HistogramSpectrum(int size, int* HistogramVector, int* InputVector, string NameSpectrum)
{
	int num_coefficient = 0, dif_coefficient = 0;
	for (int i = 0; i <= size; i++)
	{
		HistogramVector[i] = 0;
	}

	for (int i = 0; i < size; i++)
	{
		int val = (InputVector[i] + size) / 2;
		HistogramVector[val]++;
	}
	cout << "\nPrint: " << NameSpectrum << " Spectrum:\n";
	for (int i = 0; i <= size; i++)
	{

		if (HistogramVector[i] != 0)
		{
			//			cout << host_Vect_Walsh_spect[i] << " ";
			cout << (i * 2) - size << ":" << HistogramVector[i] << " ";
			num_coefficient = num_coefficient + HistogramVector[i];
			dif_coefficient++;
		}

	}
	cout << "\nNumber of coefficient:" << num_coefficient << "\n";
	cout << "Number of diffrent coefficient:" << dif_coefficient << "\n";
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
