///////////////////////////////////////////////////////////////////////////
// Copyright @2017-2023 Dusan and Iliya.  All rights reserved.
//
// Please refer to the NVIDIA end user license agreement (EULA) associated
// with this source code for terms and conditions that govern your use of
// this software. Any use, reproduction, disclosure, or distribution of
// this software and related documentation outside the terms of the EULA
// is strictly prohibited.
//
////////////////////////////////////////////////////////////////////////////
// Standard library 
#include <stdio.h>
#include <iostream>

//math.h header defines various mathematical functions and one macro
#include <math.h>

#include <chrono>

// CUDA runtime.
#include "cuda_runtime.h"

//Main Library header file
#include <BoolSPLG/BoolSPLG_v03.cuh>
//#include "BoolSPLG_v03.cuh"

using namespace std;

/////////////////////////////////////////////////////////////////////////////////////////////////////
//@@ Boolean main function - example using of GPU - CPU function for computing properties
/////////////////////////////////////////////////////////////////////////////////////////////////////
int main()
{
	cout << "==========================================================";
	printf("\nExample Boolean function BoolSPLG (version 0.3) Library algorithms.\n");
	cout << "==========================================================";
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@BoolSPLG Properties Library, Function to check if GPU fulfill BoolSPLG CUDA-capable requires
	BoolSPLGMinimalRequires();
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	cout << "==========================================================\n";
	printf("The example Boolean function will randomly generate with length according to the input exponent. \n");

	//@@Set size of Boolean vector
	cout << "\nInput 'exponent' for power function (base is 2). \n ==>The input exponent can be between 6 - 20.\n";
	cout << "\nInput exponent:";
	int size, exponent;
	cin >> exponent;
	size = (int)(pow(2, exponent));
	printf("The size length is: 2^%d=:%d\n", exponent, size);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Declaration, host_Vect_CPU - vector for CPU computation, host_Vect_GPU -vector for GPU computation, walshvec - Store result from CPU computation
	int* host_Vect_TT, * host_Vect_PTT, * host_Vect_rez, * walshvec_cpu, * anf_cpu, * rf_cpu;

	int* host_Vect_Walsh_spect, * host_Vect_AC_spect; //Spectrum vectors

	int Lin_cpu, AC_cpu, degMax_cpu;

	//Bitwise ANF computation
	unsigned long long int* host_NumIntVecTT, * host_NumIntVecANF, * host_NumIntVecANF_CPU; // , *mack_vec_Int;

	//Allocate memory block. Allocates a block of size bytes of memory
	host_Vect_TT = (int*)malloc(sizeof(int) * size);
	host_Vect_PTT = (int*)malloc(sizeof(int) * size);
	host_Vect_rez = (int*)malloc(sizeof(int) * size);
	walshvec_cpu = (int*)malloc(sizeof(int) * size);
	anf_cpu = (int*)malloc(sizeof(int) * size);
	rf_cpu = (int*)malloc(sizeof(int) * size);

	host_Vect_Walsh_spect = (int*)malloc(sizeof(int) * (size + 1)); //vector for Walsh Spectrum
	host_Vect_AC_spect = (int*)malloc(sizeof(int) * (size + 1)); //vector for AC Spectrum

	//bitwise variable and memory
	int NumOfBits = sizeof(unsigned long long int) * 8;
	int NumInt = size / NumOfBits;

	//Allocate memory block for bitwise computation
	host_NumIntVecTT = (unsigned long long int*)malloc(sizeof(unsigned long long int) * NumInt);
	host_NumIntVecANF = (unsigned long long int*)malloc(sizeof(unsigned long long int) * NumInt);
	host_NumIntVecANF_CPU = (unsigned long long int*)malloc(sizeof(unsigned long long int) * NumInt);

	int* host_max_values_AD = (int*)malloc(sizeof(int) * size);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Function: Fill random input vector for computation
	Fill_dp_vector(size, host_Vect_TT, host_Vect_PTT);
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//cout << "\nPrint input vector: ...\n";
	//Print_Result(size, host_Vect_TT);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start measuring time CPU
	auto startFWTCPU = chrono::steady_clock::now();
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Heder file "host_boolean_function.h" CPU Boolean propertie function
	//Function: Fast Walsh Transformation function CPU (W_f(f))
	FastWalshTrans(size, host_Vect_PTT, walshvec_cpu);
	Lin_cpu = reduceCPU_max(walshvec_cpu, size);
	/////////////////////////////////////////////////////////////////////////////////////////////////
	 
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@ Stop measuring time and calculate the elapsed time
	auto endFWTCPU = chrono::steady_clock::now();
	cout << "==========================================================";
	cout << "\nCPU Elapsed time in milliseconds (CPU - Lin(f)): " << chrono::duration_cast<chrono::milliseconds>(endFWTCPU - startFWTCPU).count() << " ms" << endl;
	cout << "CPU Elapsed time in nanoseconds (CPU - Lin(f)): " << chrono::duration_cast<chrono::nanoseconds>(endFWTCPU - startFWTCPU).count() << " ns" << endl;
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//cout << "\nPrint: Walsh Transform...\n";
	//Print_Result(size, walshvec_cpu);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Heder file "host_boolean_function.h" CPU function
	//Compute and print Histogram: of Walsh Spectrum
	//HistogramSpectrum(size, host_Vect_Walsh_spect, walshvec_cpu, "(CPU) Walsh");
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start measuring time CPU
	auto startANFCPU = chrono::steady_clock::now();
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Function: Fast Mobius Transformation function CPU (ANF(f))
	FastMobiushTrans(size, host_Vect_TT, anf_cpu);
	degMax_cpu = FindMaxDeg(size, anf_cpu);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@ Stop measuring time and calculate the elapsed time
	auto endANFCPU = chrono::steady_clock::now();

	cout << "\n\nCPU Elapsed time in milliseconds (CPU - deg(f)): " << chrono::duration_cast<chrono::milliseconds>(endANFCPU - startANFCPU).count() << " ms" << endl;
	cout << "CPU Elapsed time in nanoseconds (CPU - deg(f)): " << chrono::duration_cast<chrono::nanoseconds>(endANFCPU - startANFCPU).count() << " ns" << endl;
	////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start measuring time CPU
	auto startACCPU = chrono::steady_clock::now();
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Heder file "host_boolean_function.h" CPU Boolean propertie function
	//Function: Compute Autocorrelation CPU (r_f(f))
	FastWalshTrans(size, host_Vect_PTT, rf_cpu);
	fun_pow2(size, rf_cpu);
	FastWalshTransInv(size, rf_cpu);
	AC_cpu = reduceCPU_AC(size, rf_cpu);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@ Stop measuring time and calculate the elapsed time
	auto endACCPU = chrono::steady_clock::now();

	cout << "\n\nCPU Elapsed time in milliseconds (CPU - AC(f)): " << chrono::duration_cast<chrono::milliseconds>(endACCPU - startACCPU).count() << " ms" << endl;
	cout << "CPU Elapsed time in nanoseconds (CPU - AC(f)): " << chrono::duration_cast<chrono::nanoseconds>(endACCPU - startACCPU).count() << " ns" << endl;
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//cout << "\nPrint: AC Transform...\n";
	//Print_Result(size, rf_cpu);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Heder file "host_boolean_function.h" CPU Boolean propertie function
	//Compute and print Histogram: of Autocorrelation (AC) Spectrum
	//HistogramSpectrum(size, host_Vect_AC_spect, rf_cpu, "(CPU) AC");
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//CPU Boolean Bitwise comptation
	/////////////////////////////////////////////////////////////////////////////////////////////////
	int degMax_bitwise_cpu = 0;
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start measuring time CPU
	auto startFMTbitCPU = chrono::steady_clock::now();
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//convert TT bool to integers
	BinVecToDec(NumOfBits, host_Vect_TT, host_NumIntVecTT, NumInt);

	// start CPU bitwise function
	CPU_FMT_bitwise(host_NumIntVecTT, host_NumIntVecANF_CPU, NumInt);

	//conversion from decimal to binary and fine deg(f)
	degMax_bitwise_cpu = DecVecToBin_maxDeg(NumOfBits, host_NumIntVecANF_CPU, NumInt);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@ Stop measuring time and calculate the elapsed time
	auto endFMBTbitCPU = chrono::steady_clock::now();
	cout << "\n\nCPU Elapsed time in milliseconds (CPU - deg_bit(f)): " << chrono::duration_cast<chrono::milliseconds>(endFMBTbitCPU - startFMTbitCPU).count() << " ms" << endl;
	cout << "CPU Elapsed time in nanoseconds (CPU - deg_bit(f)): " << chrono::duration_cast<chrono::nanoseconds>(endFMBTbitCPU - startFMTbitCPU).count() << " ns" << endl;
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Check input size of boolean function
	cout << "\n==========================================================";
	unsigned int n_size = msb32(size);
	cout << "\nBoolean function (f) of n=" << n_size << " variables.\n";
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Start GPU program
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Call Example Boolean functions, Header File "func_call_Boolean_v03.h", v0.3
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Set and print: ShortORIntTypeDtoH datatype, Boolean functions, v0.3
	ShortORIntTypeDtoH enumdatatype = SetShortORIntTypeDtoH(size);

	printf("Data type for Devive to Host memory Transfer: %s\n", getShortORIntTypeDtoHString(enumdatatype));
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Boolean Fast Walsh Transform: return Walsh Spectra and Lin(f), v0.3
	/////////////////////////////////////////////////////////////////////////////////////////////////
	int Lin_gpu03 = 0;

	switch (enumdatatype)
	{
	case TYPE_SHORT_INT:
		{
		short int* vec_host_spectra_w = (short int*)malloc(sizeof(short int) * size);
		Lin_gpu03 = runTestWalshSpec<short int>(size, host_Vect_TT, vec_host_spectra_w, true); //last atribute true - return walsh spectra

		/////////////////////////////////////////////////////////////////////////////////////////////////
		//Compare, Check result
		/////////////////////////////////////////////////////////////////////////////////////////////////
		cout << "\nCheck result FWT(f) -> CPU vs. GPU (v0.3):";
		check_rez03(size, vec_host_spectra_w, walshvec_cpu);
		/////////////////////////////////////////////////////////////////////////////////////////////////
		free(vec_host_spectra_w);
		break;
		}

	case TYPE_INT:
		{
		int* vec_host_spectra_w = (int*)malloc(sizeof(int) * size);
		Lin_gpu03 = runTestWalshSpec<int>(size, host_Vect_TT, vec_host_spectra_w, true); //last atribute true - return walsh spectra

		/////////////////////////////////////////////////////////////////////////////////////////////////
		//Compare, Check result
		/////////////////////////////////////////////////////////////////////////////////////////////////
		cout << "\nCheck result FWT(f) -> CPU vs. GPU (v0.3):";
		check_rez03(size, vec_host_spectra_w, walshvec_cpu);
		/////////////////////////////////////////////////////////////////////////////////////////////////
		free(vec_host_spectra_w);
		break;
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Boolean Fast Mobius Transform: TT to ANF and vice versus, v0.3
	/////////////////////////////////////////////////////////////////////////////////////////////////
	switch (enumdatatype)
	{
	case TYPE_SHORT_INT:
		{
		short int* vec_host_spectra_anf_tt = (short int*)malloc(sizeof(short int) * size); //last atribute true - return Mobius Transform
		runTestMobius<short int>(size, host_Vect_TT, vec_host_spectra_anf_tt, true);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		//Compare, Check result
		//////////////////////////////////////////////////////////////////////////////////////////////////
		cout << "\nCheck result FMT(f) -> CPU vs. GPU (v0.3):";
		check_rez03(size, vec_host_spectra_anf_tt, anf_cpu);
		//////////////////////////////////////////////////////////////////////////////////////////////////
		free(vec_host_spectra_anf_tt);
		break;
		}

	case TYPE_INT:
		{
		int* vec_host_spectra_anf_tt = (int*)malloc(sizeof(int) * size);
		runTestMobius<int>(size, host_Vect_TT, vec_host_spectra_anf_tt, true); //last atribute true - return Mobius Transform (ANF-TT)

		//////////////////////////////////////////////////////////////////////////////////////////////////
		//Compare, Check result
		//////////////////////////////////////////////////////////////////////////////////////////////////
		cout << "\nCheck result FMT(f) -> CPU vs. GPU (v0.3):";
		check_rez03(size, vec_host_spectra_anf_tt, anf_cpu);
		//////////////////////////////////////////////////////////////////////////////////////////////////
		free(vec_host_spectra_anf_tt);
		break;
		}
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Boolean Algebraic Degree: deg(f), v0.3
	/////////////////////////////////////////////////////////////////////////////////////////////////
	int degMax_gpu03 = 0;

	switch (enumdatatype)
	{
	case TYPE_SHORT_INT:
		degMax_gpu03 = runTestDeg<short int>(size, host_Vect_TT);
		break;
	
	case TYPE_INT:
		degMax_gpu03 = runTestDeg<int>(size, host_Vect_TT);
		break;
	
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Set and print: SetShortORIntTypeDtoH_AC datatype for Autocorrelation Boolean functions, v0.3
	ShortORIntTypeDtoH enumdatatypeAC = SetShortORIntTypeDtoH_AC(size);

	printf("\nData type for Devive to Host memory Transfer (AC): %s\n", getShortORIntTypeDtoHString(enumdatatypeAC));
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Boolean Autocorrelation Transform: return Autocorrelation Spectra and AC(f), v0.3
	/////////////////////////////////////////////////////////////////////////////////////////////////
	int AC_gpu03 = 0;

	switch (enumdatatypeAC)
	{
	case TYPE_SHORT_INT:
		{
		short int* vec_host_spectra_act = (short int*)malloc(sizeof(short int) * size);
		AC_gpu03 = runTestACT<short int>(size, host_Vect_TT, vec_host_spectra_act, true);
		//////////////////////////////////////////////////////////////////////////////////////////////////
		//Compare, Check result
		cout << "\nCheck result AC(f) -> CPU vs. GPU (v0.3):";
		check_rez03(size, vec_host_spectra_act, rf_cpu);
		//////////////////////////////////////////////////////////////////////////////////////////////////
		free(vec_host_spectra_act);
		break;
		}

	case TYPE_INT:
		{
		int* vec_host_spectra_act = (int*)malloc(sizeof(int) * size);
		AC_gpu03 = runTestACT<int>(size, host_Vect_TT, vec_host_spectra_act, true);

		//////////////////////////////////////////////////////////////////////////////////////////////////
		//Compare, Check result
		cout << "\nCheck result AC(f) -> CPU vs. GPU (v0.3):";
		check_rez03(size, vec_host_spectra_act, rf_cpu);
		//////////////////////////////////////////////////////////////////////////////////////////////////
		free(vec_host_spectra_act);
		break;
		}

	}
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Set Device size array
	int sizeBoolean = sizeof(int) * size;

	//Declaration device vectors
	int* device_Vect, * device_Vect_rez;

	unsigned long long int* device_NumIntVecTT, * device_NumIntVecANF;
	int* device_max_values_AD;
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Set and Call Boolean Fast Walsh Transform
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@ Allocate GPU memory here

	//check CUDA component status
	cudaError_t cudaStatus;

	//input device vector
	cudaStatus = cudaMalloc((void**)&device_Vect, sizeBoolean);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}
	//output device vector
	cudaStatus = cudaMalloc((void**)&device_Vect_rez, sizeBoolean);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//input integer TT device vector
	cudaStatus = cudaMalloc((void**)&device_NumIntVecTT, sizeof(unsigned long long int) * NumInt);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//output integer ANF device vector
	cudaStatus = cudaMalloc((void**)&device_NumIntVecANF, sizeof(unsigned long long int) * NumInt);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//device max AD on every integer
	cudaStatus = cudaMalloc((void**)&device_max_values_AD, sizeof(int) * NumInt);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMalloc failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start mesure time HostToDevice
	cudaEvent_t startHToD_PTT, stopHToD_PTT;

	cudaEventCreate(&startHToD_PTT);
	cudaEventCreate(&stopHToD_PTT);

	cudaEventRecord(startHToD_PTT);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	// Copy input vectors from host memory to GPU buffers.
	cudaStatus = cudaMemcpy(device_Vect, host_Vect_PTT, sizeBoolean, cudaMemcpyHostToDevice);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Stop mesure time HostToDevice
	cudaEventRecord(stopHToD_PTT);
	cudaEventSynchronize(stopHToD_PTT);
	float elapsedTimeHToD_PTT = 0;
	cudaEventElapsedTime(&elapsedTimeHToD_PTT, startHToD_PTT, stopHToD_PTT);
	cout << "\n============================================\n";
	printf("\n(GPU HostToDevice) Time taken to copy PTT(f) (int): %3.6f ms \n", elapsedTimeHToD_PTT);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	printf("  Time taken to copy NumIntVecTT32 (unsigned int): %f sec\n", elapsedTimeHToD_PTT * 1e-3);
	printf("  Number of int variables: %d, Transfer Size (Bytes): %d \n", size, sizeBoolean);
	printf("  Host to Device Bandwidth (GB/s): %f\n", sizeBoolean * 1e-6 / elapsedTimeHToD_PTT);

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library FWT(f) two - function diffrent functions for FWT(f) calculation
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start mesure time compute FWT GPU
	cudaEvent_t startTimeFWT, stopTimeFWT;

	cudaEventCreate(&startTimeFWT);
	cudaEventCreate(&stopTimeFWT);

	cudaEventRecord(startTimeFWT);
	/////////////////////////////////////////////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library, Boolean Fast Walsh Transform: return Walsh Spectra and Lin(f)
	/////////////////////////////////////////////////////////////////////////////////////////////////
	//Lin_gpu = WalshSpecTranBoolGPU(device_Vect, device_Vect_rez, size, true); //use reduction Max
	int Lin_gpu = WalshSpecTranBoolGPU_ButterflyMax(device_Vect, device_Vect_rez, size, true); //use Butterfly Max
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Stop mesure time compute FWT GPU
	cudaEventRecord(stopTimeFWT);
	cudaEventSynchronize(stopTimeFWT);
	float elapsedTimeFWT = 0;
	cudaEventElapsedTime(&elapsedTimeFWT, startTimeFWT, stopTimeFWT);

	cout << "\n============================================\n";
	printf("\n(GPU, old) Time taken to Compute Lin(S): %3.6f ms \n", elapsedTimeFWT);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//Copy output vector from GPU buffer to host memory.
	cudaStatus = cudaMemcpy(host_Vect_rez, device_Vect_rez, sizeBoolean, cudaMemcpyDeviceToHost);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Print GPU FWT result
	//cout << "\nPrint FWT(f) GPU: ...\n";
	//Print_Result(size, host_Vect_rez);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Compare, Check result
	cout << "\nCheck result FWT(f) -> CPU vs. GPU:";
	//Help Heder file "func_Boolean_CPU.h" function
	check_rez(size, host_Vect_rez, walshvec_cpu);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	cout << "\nLin(f)_cpu:" << Lin_cpu << "\n";
	cout << "Lin(f)_gpu:" << Lin_gpu << "\n";
	cout << "Lin(f)_gpu(v0.3):" << Lin_gpu03 << "\n";
	cout << "\n============================================\n";
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Set and Call Boolean Fast Mobius Transform
	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Copy input vectors from host memory to GPU buffers.
	cudaStatus = cudaMemcpy(device_Vect, host_Vect_TT, sizeBoolean, cudaMemcpyHostToDevice);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library, Boolean Fast Mobius Transform FMT(f): TT to ANF and vice versus
	//////////////////////////////////////////////////////////////////////////////////////////////////
	MobiusTranBoolGPU(device_Vect, device_Vect_rez, size);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Copy output vector from GPU buffer to host memory.
	cudaStatus = cudaMemcpy(host_Vect_rez, device_Vect_rez, sizeBoolean, cudaMemcpyDeviceToHost);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Compare, Check FMT(f) result
	cout << "\nCheck result (ANF) FMT(f) -> CPU vs. GPU:";
	check_rez(size, host_Vect_rez, anf_cpu);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library FMT(f) function - two diffrent functions for FMT(f) - Algebraic Degree calculation
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start mesure time compute ANF GPU
	cudaEvent_t startTimeANF, stopTimeANF;

	cudaEventCreate(&startTimeANF);
	cudaEventCreate(&stopTimeANF);

	cudaEventRecord(startTimeANF);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library, Boolean Algebraic Degree function: return deg(f)
	//////////////////////////////////////////////////////////////////////////////////////////////////
	//degMax_gpu = AlgebraicDegreeBoolGPU(device_Vect, device_Vect_rez, size); //use reduction Max
	int degMax_gpu = AlgebraicDegreeBoolGPU_ButterflyMax(device_Vect, device_Vect_rez, size); //use Butterfly Max
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Stop mesure time compute ANF GPU
	cudaEventRecord(stopTimeANF);
	cudaEventSynchronize(stopTimeANF);
	float elapsedTimeANF = 0;
	cudaEventElapsedTime(&elapsedTimeANF, startTimeANF, stopTimeANF);

	printf("\n(GPU, old) Time taken to Compute deg(S): %3.6f ms \n", elapsedTimeANF);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
		//goto Error;
		exit(EXIT_FAILURE);
	}

	// Copy output vector from GPU buffer to host memory.
	cudaStatus = cudaMemcpy(host_Vect_rez, device_Vect_rez, sizeBoolean, cudaMemcpyDeviceToHost);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Set and Call Boolean Bitwise Fast Mobius Transform
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//convert bool into integers
	BinVecToDec(NumOfBits, host_Vect_TT, host_NumIntVecTT, NumInt);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start mesure time Host To Device
	cudaEvent_t startHToD_NumIntVecTT, stopHToD_NumIntVecTT;

	cudaEventCreate(&startHToD_NumIntVecTT);
	cudaEventCreate(&stopHToD_NumIntVecTT);

	cudaEventRecord(startHToD_NumIntVecTT);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	// Copy input TT (integer) vector from host memory to GPU buffers.
	cudaStatus = cudaMemcpy(device_NumIntVecTT, host_NumIntVecTT, sizeof(unsigned long long int) * NumInt, cudaMemcpyHostToDevice);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Stop mesure time Host To Device
	cudaEventRecord(stopHToD_NumIntVecTT);
	cudaEventSynchronize(stopHToD_NumIntVecTT);
	float elapsedTimeHToD_NumIntVecTT = 0;
	cudaEventElapsedTime(&elapsedTimeHToD_NumIntVecTT, startHToD_NumIntVecTT, stopHToD_NumIntVecTT);

	printf("\n(GPU HostToDevice) Time taken to copy NumIntVecTT (unsigned long long int): %3.6f ms \n", elapsedTimeHToD_NumIntVecTT);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	printf("  Time taken to copy NumIntVecTT32 (unsigned int): %f sec\n", elapsedTimeHToD_NumIntVecTT * 1e-3);
	printf("  Number of (unsigned long long) int variables: %d, Transfer Size (Bytes): %zu \n", NumInt, sizeof(unsigned long long int) * NumInt);
	printf("  Host to Device Bandwidth (GB/s): %f\n", sizeof(unsigned long long int)* NumInt * 1e-6 / elapsedTimeHToD_NumIntVecTT);

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library, Boolean bitwise Fast Mobius Transform FMT(f): TT to ANF and vice versus
	//////////////////////////////////////////////////////////////////////////////////////////////////
	BitwiseMobiusTranBoolGPU(device_NumIntVecTT, device_NumIntVecANF, size);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
		//goto Error;
		exit(EXIT_FAILURE);
	}

	// Copy output vector from GPU buffer to host memory.
	cudaStatus = cudaMemcpy(host_NumIntVecANF, device_NumIntVecANF, sizeof(unsigned long long int) * NumInt, cudaMemcpyDeviceToHost);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	cout << "\nCheck result 'bitwise' (integer variables) FMT(f)->CPU vs.GPU:";
	check_rez_int(NumInt, host_NumIntVecANF, host_NumIntVecANF_CPU);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library FMT(f) function - Bitwise Algebraic Degree calculation
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start mesure time compute ANF bitwise GPU
	cudaEvent_t startTimeANFbit, stopTimeANFbit;

	cudaEventCreate(&startTimeANFbit);
	cudaEventCreate(&stopTimeANFbit);

	cudaEventRecord(startTimeANFbit);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library, Boolean bitwise Algebraic Degree function: return deg(f)
	//////////////////////////////////////////////////////////////////////////////////////////////////
	int	degMax_bitwise_gpu = BitwiseAlgebraicDegreeBoolGPU_ButterflyMax(device_NumIntVecTT, device_NumIntVecANF, device_max_values_AD, host_max_values_AD, size);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Stop mesure time compute ANF bitwise GPU
	cudaEventRecord(stopTimeANFbit);
	cudaEventSynchronize(stopTimeANFbit);
	float elapsedTimeANFbit = 0;
	cudaEventElapsedTime(&elapsedTimeANFbit, startTimeANFbit, stopTimeANFbit);

	printf("\n(GPU, old) Time taken to Compute deg(S)(bitwise): %3.6f ms \n", elapsedTimeANFbit);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
		//goto Error;
		exit(EXIT_FAILURE);
	}
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	if (n_size < 6)
		cout << "\n Algebraic Degree Bitwise computation is not working for n<6.\n";
	//Print deg(f) result
	cout << "\ndeg(f)max_cpu:" << degMax_cpu << "\n";
	cout << "deg(f)max_cpu(bitwise):" << degMax_bitwise_cpu << "\n";
	cout << "deg(f)max_gpu:" << degMax_gpu << "\n";
	cout << "deg(f)max_gpu(bitwise):" << degMax_bitwise_gpu << "\n";
	cout << "deg(f)max_gpu(v0.3):" << degMax_gpu03 << "\n";
	cout << "\n============================================\n";
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Set Function to compute Autocorrelation (r_f(f))
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// Copy input vectors from host memory to GPU buffers.
	cudaStatus = cudaMemcpy(device_Vect, host_Vect_PTT, sizeBoolean, cudaMemcpyHostToDevice);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library ACT(f) function - two diffrent functions for ACT(f) calculation
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Start mesure time compute ACT GPU
	cudaEvent_t startTimeACT, stopTimeACT;

	cudaEventCreate(&startTimeACT);
	cudaEventCreate(&stopTimeACT);

	cudaEventRecord(startTimeACT);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Call BoolSPLG Library, Boolean Autocorrelation Transform function ACT: return Autocorrelation spectra and AC(f)
	//////////////////////////////////////////////////////////////////////////////////////////////////
	//AC_gpu = AutocorrelationTranBoolGPU(device_Vect, device_Vect_rez, size, true); //use reduction Max
	int AC_gpu = AutocorrelationTranBoolGPU_ButterflyMax(device_Vect, device_Vect_rez, size, true); //use Butterfly Max
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@@Stop mesure time compute ACT GPU
	cudaEventRecord(stopTimeACT);
	cudaEventSynchronize(stopTimeACT);
	float elapsedTimeACT = 0;
	cudaEventElapsedTime(&elapsedTimeACT, startTimeACT, stopTimeACT);

	printf("\n(GPU, old) Time taken to Compute AC(S): %3.6f ms \n", elapsedTimeACT);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	// cudaDeviceSynchronize waits for the kernel to finish, and returns
	// any errors encountered during the launch.
	cudaStatus = cudaDeviceSynchronize();
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaDeviceSynchronize returned error code %d after launching addKernel!\n", cudaStatus);
		//goto Error;
		exit(EXIT_FAILURE);
	}

	// Copy output vector from GPU buffer to host memory.
	cudaStatus = cudaMemcpy(host_Vect_rez, device_Vect_rez, sizeBoolean, cudaMemcpyDeviceToHost);
	if (cudaStatus != cudaSuccess) {
		fprintf(stderr, "cudaMemcpy failed!");
		//goto Error;
		exit(EXIT_FAILURE);
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//Compere, Check result
	cout << "\nCheck result AC(f) -> CPU vs. GPU:";
	check_rez(size, host_Vect_rez, rf_cpu);
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	cout << "\nAC(f)_cpu:" << AC_cpu << "\n";
	cout << "AC(f)_gpu:" << AC_gpu << "\n";
	cout << "AC(f)_gpu(v0.3):" << AC_gpu03 << "\n";
	cout << "\n============================================\n";
	//////////////////////////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////////////////////////
	//@Free memory
	cudaFree(device_Vect);
	cudaFree(device_Vect_rez);

	free(host_Vect_TT);
	free(host_Vect_PTT);
	free(host_Vect_rez);
	free(walshvec_cpu);
	free(anf_cpu);
	free(rf_cpu);

	free(host_NumIntVecTT);
	free(host_NumIntVecANF);
	free(host_NumIntVecANF_CPU);

	free(host_max_values_AD);

	free(host_Vect_Walsh_spect); //Walsh spectra
	free(host_Vect_AC_spect); //Walsh spectra
	//////////////////////////////////////////////////////////////////////////////////////////////////
	printf("\n   --- End Example, Boolean function BoolSPLG (version 0.3) Library algorithms. ---\n\n");
	//////////////////////////////////////////////////////////////////////////////////////////////////

	return 0;
}
